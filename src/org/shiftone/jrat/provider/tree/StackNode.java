package org.shiftone.jrat.provider.tree;

import org.shiftone.jrat.core.Accumulator;
import org.shiftone.jrat.core.MethodKey;

import org.shiftone.jrat.provider.tree.ui.TreeOutputXmlViewerFactory;

import org.shiftone.jrat.util.StringUtil;

import org.shiftone.jrat.util.log.Log;
import org.shiftone.jrat.util.log.LogFactory;

import java.io.PrintStream;

import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;


/**
 * Class StackNode
 *
 * @author <a href="mailto:jeff@shiftone.org">Jeff Drost</a>
 * @version $Revision: 1.9 $
 */
public class StackNode extends Accumulator {

    private static final Log   LOG = LogFactory.getLogger(StackNode.class);
    public static final String VERSION   = StringUtil.revision("$Revision: 1.9 $");
    protected MethodKey        methodKey = null;
    protected StackNode        parent    = null;
    protected Map              children  = new HashMap();

    /**
     * Constructor StackNode
     *
     */
    public StackNode() {

        //LOG.debug("new StackNode - root node");
    }

    /**
     * Constructor StackNode
     *
     *
     * @param methodKey
     * @param treeNode
     */
    public StackNode(MethodKey methodKey, StackNode treeNode) {

        //LOG.debug("new StackNode : " + methodKey);
        this.methodKey     = methodKey;
        this.parent        = treeNode;

    }

    /**
     * Method gets <b>AND CREATES IF NEEDED</b> the requested tree node
     */
    public StackNode getChild(MethodKey methodKey) {

        StackNode treeNode = null;

        synchronized (children) {

            treeNode = (StackNode) children.get(methodKey);

            if (treeNode == null) {

                treeNode = new StackNode(methodKey, this);

                children.put(methodKey, treeNode);

            }

        }

        return treeNode;

    }

    /**
     * Method getParent
     */
    public final StackNode getParentNode() {

        return parent;

    }

    /**
     * Method isRootNode
     */
    public final boolean isRootNode() {

        return (methodKey == null);

    }

    /**
     * Method getMethodKey
     */
    public MethodKey getMethodKey() {

        return methodKey;

    }

    /**
     * Method printXML
     */
    public void printXML(PrintStream out) {

        LOG.info("printXML...");

        if (isRootNode()) {

            printRoot(out);

        } else {

            // this should never happen
            printNonRoot(out, 0);

        }

        LOG.info("checkError = " + out.checkError());

    }

    /**
     * Method printRoot
     */
    private void printRoot(PrintStream out) {

        LOG.info("printRoot...");

        out.println("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>");
        out.println("<!-- generated by JRat 'call tree' " + VERSION + " provider on " + new Date() + "-->");
        out.println("<jrat-tree viewer=\"" + TreeOutputXmlViewerFactory.class.getName() + "\">");
        out.println("<view>");
        printChildren(out, 0);
        out.println("</view>");
        out.println("</jrat-tree>");

    }

    /**
     * Method printNonRoot
     */
    private void printNonRoot(PrintStream out, int depth) {

        out.print(StringUtil.bufferString(depth, ' '));
        out.print("<call");
        out.print(" c=\"" + methodKey.getClassName() + "\"");
        out.print(" m=\"" + methodKey.getMethodName() + "\"");
        out.print(" s=\"" + methodKey.getSignature() + "\"");
        out.print(" ent=\"" + getTotalEnters() + "\"");
        out.print(" xit=\"" + getTotalExits() + "\"");
        out.print(" err=\"" + getTotalErrors() + "\"");
        out.print(" dur=\"" + getTotalDuration() + "\"");
        out.print(" sos=\"" + getSumOfSquares() + "\"");

        if (getTotalDuration() != 0) {

            out.print(" min=\"" + getMinDuration() + "\"");
            out.print(" max=\"" + getMaxDuration() + "\"");

        }

        if (children.size() > 0) {

            out.println(">");
            printChildren(out, depth);
            out.print(StringUtil.bufferString(depth, ' '));
            out.println("</call>");

        } else {

            out.println("/>");

        }

    }

    /**
     * Method printChildren
     */
    private void printChildren(PrintStream out, int depth) {

        children = Collections.unmodifiableMap(children);

        Collection collection = children.values();
        Iterator   iterator = collection.iterator();
        StackNode  treeNode = null;

        while (iterator.hasNext()) {

            treeNode = (StackNode) iterator.next();

            treeNode.printNonRoot(out, depth + 1);

        }

    }

    // ---------------------------------------------------------------
}
